<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title><%= typeof title !== "undefined" ? title : "Marketmind" %></title>
  <link rel="stylesheet" href="/css/styles.css" />
  <link rel="stylesheet" href="/css/portfolio.css" />

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    .p-btn{ padding:10px 12px; border-radius:10px; border:1px solid rgba(255,255,255,.14); background:#111; color:#eee; cursor:pointer; text-decoration:none; display:inline-flex; align-items:center; gap:8px; }
    .p-btn.primary{ background:#00eaff; color:#000; border-color:transparent; font-weight:800; }
    .risk-bad{ color:#ffcc00; font-weight:800; }
  </style>
</head>

<%- include('partials/head') %>

<body class="portfolio-page">
  <%- include("partials/navbar") %>

  <%
    const totalValue = Number((portfolio && portfolio.totalValue) ?? 0);
    const holdings = (portfolio && Array.isArray(portfolio.holdings)) ? portfolio.holdings : [];
  %>

  <main class="portfolio-shell">
    <div class="portfolio-header">
      <div>
        <h1 class="portfolio-title">My Portfolio</h1>
        <div class="portfolio-subtitle">30D daily performance + today’s hourly updates</div>
      </div>

      <div id="liveStatusPill" class="live-pill offline">Live: Offline</div>
    </div>

    <div class="portfolio-grid">
      <!-- LEFT -->
      <div class="left-stack">
        <section class="p-card">
          <div class="card-row">
            <div>
              <div class="card-kicker">Total Portfolio Value</div>

              <div id="liveValue" class="big-value">
                $<%= totalValue.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 }) %>
              </div>

              <!-- ✅ Option A: Unrealised P/L since purchase (JS will fill it) -->
              <div id="liveChange" class="change-row">
                <span class="muted">—</span>
              </div>

              <div class="subtext">Unrealised P/L since purchase (updates with live prices)</div>

              <div style="margin-top:14px;">
                <a href="/paper-trading" class="p-btn primary">Go to Paper Trading →</a>
              </div>
            </div>

            <div class="meta-right">
              <div class="meta-title">Refresh</div>
              <div class="meta-value">1h</div>
            </div>
          </div>
        </section>

        <section class="p-card">
          <div class="card-row">
            <h2 class="card-title">Current Positions</h2>
            <div class="subtext">Live price, market value, P/L</div>
          </div>

          <div class="table-wrap">
            <table class="p-table">
              <thead>
                <tr>
                  <th>Symbol</th>
                  <th>Qty</th>
                  <th>Cost Price</th>
                  <th>Live Price</th>
                  <th>Market Value</th>
                  <th>P/L</th>
                  <th>Risk</th>
                </tr>
              </thead>

              <tbody>
                <% if (holdings.length === 0) { %>
                  <tr>
                    <td colspan="7" class="subtext">No holdings yet. Use Paper Trading to create positions.</td>
                  </tr>
                <% } else { %>
                  <% holdings.forEach(item => {
                      const sym = String(item.symbol || "").toUpperCase();
                      const qty = Number(item.qty ?? 0);
                      const avg = Number(item.avg ?? 0);
                  %>
                    <tr data-symbol="<%= sym %>">
                      <td class="sym"><%= sym %></td>
                      <td class="qty"><%= qty %></td>
                      <td class="avg" data-avg="<%= avg %>">$<%= avg.toFixed(2) %></td>
                      <td class="livePrice muted">—</td>
                      <td class="marketValue muted">—</td>
                      <td class="pl muted">—</td>
                      <td class="risk muted">—</td>
                    </tr>
                  <% }) %>
                <% } %>
              </tbody>
            </table>
          </div>
        </section>
      </div>

      <!-- RIGHT -->
      <div class="right-stack">
        <section class="p-card">
          <div class="card-row">
            <h2 class="card-title">Stock Allocation (Live)</h2>
            <div class="subtext">By market value</div>
          </div>

          <div class="chart-wrap">
            <canvas id="sectorChart"></canvas>
          </div>
        </section>

        <section class="p-card">
          <div class="card-row">
            <h2 class="card-title">Portfolio Performance (30D + Today)</h2>
            <div class="subtext">Daily history + hourly points for today</div>
          </div>

          <div class="chart-wrap">
            <canvas id="trendChart"></canvas>
          </div>
        </section>
      </div>
    </div>
  </main>

  <script>
    const liveValueText = document.getElementById("liveValue");
    const liveStatusPill = document.getElementById("liveStatusPill");
    const liveChangeEl = document.getElementById("liveChange");

    const sectorCtx = document.getElementById("sectorChart").getContext("2d");
    const trendCtx = document.getElementById("trendChart").getContext("2d");

    function setStatus(ok) {
      if (ok) {
        liveStatusPill.textContent = "Live: Connected";
        liveStatusPill.classList.remove("offline");
        liveStatusPill.classList.add("online");
      } else {
        liveStatusPill.textContent = "Live: Offline";
        liveStatusPill.classList.remove("online");
        liveStatusPill.classList.add("offline");
      }
    }

    function formatMoney(n) {
      const x = Number(n || 0);
      return "$" + x.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    }

    function pad2(n) { return String(n).padStart(2, "0"); }

    function currentHourKey(d = new Date()) {
      return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())} ${pad2(d.getHours())}`;
    }

    function currentHourLabel(d = new Date()) {
      return `Today ${pad2(d.getHours())}:00`;
    }

    const sectorChart = new Chart(sectorCtx, {
      type: "doughnut",
      data: { labels: [], datasets: [{ data: [] }] },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: false,
        plugins: { legend: { labels: { color: "rgba(255,255,255,0.75)" } } }
      }
    });

    const trendChart = new Chart(trendCtx, {
      type: "line",
      data: { labels: [], datasets: [{ label: "Portfolio Value", data: [] }] },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: false,
        scales: {
          x: { ticks: { color: "rgba(255,255,255,0.65)" }, grid: { color: "rgba(255,255,255,0.08)" } },
          y: { ticks: { color: "rgba(255,255,255,0.65)" }, grid: { color: "rgba(255,255,255,0.08)" } }
        },
        plugins: { legend: { labels: { color: "rgba(255,255,255,0.75)" } } }
      }
    });

    function updateHoldingsTable(allocation) {
      const bySymbol = new Map();
      allocation.forEach(a => bySymbol.set(String(a.symbol || "").toUpperCase(), a));

      document.querySelectorAll("tr[data-symbol]").forEach(row => {
        const sym = row.getAttribute("data-symbol");
        const info = bySymbol.get(sym);
        if (!info) return;

        const qty = Number(row.querySelector(".qty")?.textContent || 0);
        const avg = Number(row.querySelector(".avg")?.getAttribute("data-avg") || 0);

        const livePrice = Number(info.price);
        const mv = Number(info.value);

        const liveCell = row.querySelector(".livePrice");
        const mvCell = row.querySelector(".marketValue");
        const plCell = row.querySelector(".pl");
        const riskCell = row.querySelector(".risk");

        if (Number.isFinite(livePrice)) {
          liveCell.classList.remove("muted");
          liveCell.textContent = formatMoney(livePrice);
        } else {
          liveCell.classList.add("muted");
          liveCell.textContent = "—";
        }

        if (Number.isFinite(mv)) {
          mvCell.classList.remove("muted");
          mvCell.textContent = formatMoney(mv);
        } else {
          mvCell.classList.add("muted");
          mvCell.textContent = "—";
        }

        if (Number.isFinite(livePrice) && Number.isFinite(avg) && Number.isFinite(qty)) {
          const pl = (livePrice - avg) * qty;
          const sign = pl >= 0 ? "+" : "-";
          plCell.classList.remove("muted");
          plCell.classList.toggle("pl-pos", pl >= 0);
          plCell.classList.toggle("pl-neg", pl < 0);
          plCell.textContent = sign + formatMoney(Math.abs(pl));
        } else {
          plCell.classList.add("muted");
          plCell.classList.remove("pl-pos", "pl-neg");
          plCell.textContent = "—";
        }

        const stockRisk = info.stockRisk || null;
        const warn = !!info.riskWarning;

        if (stockRisk) {
          riskCell.classList.remove("muted");
          riskCell.classList.toggle("risk-bad", warn);
          riskCell.textContent = warn ? `⚠️ ${stockRisk}` : stockRisk;
        } else {
          riskCell.classList.add("muted");
          riskCell.classList.remove("risk-bad");
          riskCell.textContent = "—";
        }
      });
    }

    // unrealised P/L (since purchase)
    function updateSincePurchaseChange(allocation) {
      if (!Array.isArray(allocation) || allocation.length === 0) {
        liveChangeEl.innerHTML = `<span class="muted">—</span>`;
        return;
      }

      let invested = 0;
      let marketValue = 0;

      for (const a of allocation) {
        const qty = Number(a.qty || 0);
        const avg = Number(a.avg || 0);
        const price = Number(a.price || 0);

        invested += qty * avg;
        marketValue += qty * price;
      }

      const diff = marketValue - invested;
      const pct = invested > 0 ? (diff / invested) * 100 : 0;

      const sign = diff >= 0 ? "+" : "-";
      const cls = diff >= 0 ? "pos" : "neg";

      liveChangeEl.innerHTML = `
        <span class="${cls}">
          ${sign}${formatMoney(Math.abs(diff))} (${sign}${Math.abs(pct).toFixed(2)}%)
        </span>
      `;
    }

    let lastHourKeyAdded = null;

    function appendHourlyPoint(liveTotal) {
      const now = new Date();
      const key = currentHourKey(now);
      const label = currentHourLabel(now);

      if (lastHourKeyAdded === key) return;
      lastHourKeyAdded = key;

      trendChart.data.labels.push(label);
      trendChart.data.datasets[0].data.push(Number(liveTotal || 0));

      if (trendChart.data.labels.length > 80) {
        trendChart.data.labels.shift();
        trendChart.data.datasets[0].data.shift();
      }

      trendChart.update();
    }

    async function fetchLivePortfolioAndUpdateUI(addHourlyPoint = false) {
      try {
        const res = await fetch("/api/portfolio-live");
        if (!res.ok) { setStatus(false); return; }

        const data = await res.json();
        if (!data || data.ok === false) { setStatus(false); return; }

        setStatus(true);

        const liveTotal = Number(data.totalValue || 0);
        liveValueText.textContent = formatMoney(liveTotal);

        if (Array.isArray(data.allocation)) {
          // ✅ Option A uses allocation to compute since-purchase P/L
          updateSincePurchaseChange(data.allocation);

          sectorChart.data.labels = data.allocation.map(a => String(a.symbol || "").toUpperCase());
          sectorChart.data.datasets = [{ data: data.allocation.map(a => Number(a.value || 0)) }];
          sectorChart.update();

          updateHoldingsTable(data.allocation);
        } else {
          updateSincePurchaseChange([]);
        }

        if (addHourlyPoint) appendHourlyPoint(liveTotal);
      } catch {
        setStatus(false);
      }
    }

    async function loadPortfolioHistory30D() {
      try {
        const res = await fetch("/api/portfolio-history");
        if (!res.ok) return;

        const data = await res.json();
        if (!data || !Array.isArray(data.labels) || !Array.isArray(data.values)) return;

        trendChart.data.labels = data.labels.slice();
        trendChart.data.datasets[0].data = data.values.slice();
        trendChart.update();
      } catch {}
    }

    function msUntilNextHour() {
      const now = new Date();
      const next = new Date(now);
      next.setMinutes(0, 0, 0);
      next.setHours(now.getHours() + 1);
      return Math.max(1000, next - now);
    }

    setStatus(false);

    (async function initPortfolio() {
      await loadPortfolioHistory30D();

      await fetchLivePortfolioAndUpdateUI(true);

      setTimeout(() => {
        fetchLivePortfolioAndUpdateUI(true);
        setInterval(() => fetchLivePortfolioAndUpdateUI(true), 60 * 60 * 1000);
      }, msUntilNextHour());
    })();
  </script>
</body>
</html>
